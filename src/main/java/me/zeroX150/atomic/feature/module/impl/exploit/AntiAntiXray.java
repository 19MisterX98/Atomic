package me.zeroX150.atomic.feature.module.impl.exploit;

import com.google.common.collect.Lists;
import me.zeroX150.atomic.Atomic;
import me.zeroX150.atomic.feature.gui.notifications.Notification;
import me.zeroX150.atomic.feature.module.Module;
import me.zeroX150.atomic.feature.module.ModuleType;
import me.zeroX150.atomic.feature.module.config.MultiValue;
import me.zeroX150.atomic.feature.module.config.SliderValue;
import me.zeroX150.atomic.feature.module.impl.world.XRAY;
import me.zeroX150.atomic.helper.Client;
import me.zeroX150.atomic.helper.Renderer;
import net.minecraft.block.Block;
import net.minecraft.block.BlockState;
import net.minecraft.block.Blocks;
import net.minecraft.client.util.math.MatrixStack;
import net.minecraft.network.packet.c2s.play.PlayerActionC2SPacket;
import net.minecraft.util.math.BlockPos;
import net.minecraft.util.math.Direction;
import net.minecraft.util.math.Vec3d;

import java.util.ArrayList;
import java.util.List;

public class AntiAntiXray extends Module {
    SliderValue range = (SliderValue) this.config.create("Range", 16, 2, 64, 0).description("The range to scan ores in");
    SliderValue skipDistance = (SliderValue) this.config.create("Skip distance", 2, 0, 6, 1).description("The distance around a ore to skip scans in");
    MultiValue mode = (MultiValue) this.config.create("Mode", "Ores", "Ores", "Stone", "Diamond", "Redstone", "Iron", "Netherite", "Everything").description("The mode");
    SliderValue blocksPerTick = (SliderValue) this.config.create("Blocks per tick", 10, 1, 20, 0).description("The amount of blocks scanned per tick");
    SliderValue delay = (SliderValue) this.config.create("Delay", 0, 0, 20, 0).description("The delay between scan iterations");

    List<BlockPos> toScan = Lists.newArrayList();
    Vec3d startPos;
    List<BlockPos> renders = new ArrayList<>();
    int scanned = 0;
    int delayPassed = 0;

    public AntiAntiXray() {
        super("AntiAntiXray", "fuck you antixray i hope you choke on garlic", ModuleType.EXPLOIT);
    }

    boolean isBlockValid(Block b) {
        return switch (mode.getValue().toLowerCase()) {
            case "ores" -> XRAY.blocks.contains(b); // ores mode
            case "stone" -> b == Blocks.STONE; // stone mode
            case "diamond" -> b == Blocks.DIAMOND_ORE; // diamond ore mode
            case "redstone" -> b == Blocks.REDSTONE_ORE; // redstone ore mode
            case "iron" -> b == Blocks.IRON_ORE; // iron ore mode
            case "netherite" -> b == Blocks.ANCIENT_DEBRIS; // ancient debris mode
            default -> true; // everything mode
        };
    }

    @Override
    public void tick() {
        if (Atomic.client.player == null || Atomic.client.getNetworkHandler() == null) return;
        if (toScan.size() == 0) {
            Notification.create(5000, "AntiAntiXray", "Done scanning ores!");
            toggle();
            return;
        }
        if (delayPassed > delay.getValue()) {
            delayPassed = 0;
        } else {
            delayPassed++;
            return;
        }
        renders.clear();
        for (int i = 0; i < blocksPerTick.getValue(); i++) {
            if (toScan.size() == 0) break;
            BlockPos current = toScan.get(0);
            renders.add(current);
            toScan.remove(0);
            scanned++;

            PlayerActionC2SPacket p = new PlayerActionC2SPacket(PlayerActionC2SPacket.Action.ABORT_DESTROY_BLOCK, current,
                    Direction.DOWN);
            Atomic.client.getNetworkHandler().sendPacket(p);
        }
    }

    @Override
    public void enable() {
        if (Atomic.client.player == null || Atomic.client.world == null) return;
        toScan.clear();
        scanned = 0;
        startPos = Atomic.client.player.getPos();
        BlockPos ppos = Atomic.client.player.getBlockPos();
        Vec3d lastPos = Vec3d.ZERO;
        int rangeMid = (int) (range.getValue() / 2);
        for (int y = rangeMid; y > -rangeMid; y--) {
            for (int x = -rangeMid; x < rangeMid; x++) {
                for (int z = -rangeMid; z < rangeMid; z++) {
                    BlockPos current = ppos.add(x, y, z);
                    BlockState bs = Atomic.client.world.getBlockState(current);
                    Vec3d currentPos = new Vec3d(current.getX(), current.getY(), current.getZ());
                    if (!bs.isAir() && lastPos.distanceTo(currentPos) >= skipDistance.getValue()) {
                        if (isBlockValid(bs.getBlock())) {
                            toScan.add(current);
                            lastPos = currentPos;
                        }
                    }
                }
            }
        }
    }

    @Override
    public void disable() {

    }

    @Override
    public String getContext() {
        return "[" + scanned + "S;" + toScan.size() + "R]";
    }

    @Override
    public void onWorldRender(MatrixStack matrices) {
        for (BlockPos latestScan : renders.toArray(new BlockPos[0])) {
            Renderer.renderFilled(new Vec3d(latestScan.getX(), latestScan.getY(), latestScan.getZ()), new Vec3d(1, 1, 1), Client.getCurrentRGB(), matrices);
        }
        double mid = this.range.getValue() / 2;
        Vec3d s = new Vec3d(mid, mid, mid);
        Vec3d ppOrigin = startPos;
        Vec3d boxOrigin = ppOrigin.subtract(s);
        Renderer.renderOutline(boxOrigin, s.multiply(2), Client.getCurrentRGB(), matrices);
    }

    @Override
    public void onHudRender() {

    }
}

