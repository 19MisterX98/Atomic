package me.zeroX150.atomic.feature.module.impl.exploit;

import me.zeroX150.atomic.Atomic;
import me.zeroX150.atomic.feature.gui.notifications.Notification;
import me.zeroX150.atomic.feature.module.Module;
import me.zeroX150.atomic.feature.module.ModuleType;
import me.zeroX150.atomic.feature.module.config.BooleanValue;
import me.zeroX150.atomic.feature.module.config.MultiValue;
import me.zeroX150.atomic.feature.module.config.SliderValue;
import me.zeroX150.atomic.helper.HologramManager;
import me.zeroX150.atomic.helper.event.Events;
import me.zeroX150.atomic.helper.event.PacketEvents;
import net.minecraft.client.util.math.MatrixStack;
import net.minecraft.item.ItemStack;
import net.minecraft.item.Items;
import net.minecraft.network.packet.c2s.play.CreativeInventoryActionC2SPacket;
import net.minecraft.network.packet.c2s.play.PlayerInteractBlockC2SPacket;
import net.minecraft.util.math.Vec3d;

import javax.imageio.ImageIO;
import java.awt.*;
import java.awt.image.BufferedImage;
import java.io.InputStream;
import java.net.HttpURLConnection;
import java.net.URL;
import java.util.ArrayList;
import java.util.List;
import java.util.Random;

public class HologramAura extends Module {
    public static String text;
    public static String argument;
    public MultiValue mode = (MultiValue) this.config.create("Mode", "Random", "Random", "Sphere", "Image").description("The mode to place armor stands by");
    List<Vec3d> genSpherePoints = new ArrayList<>();
    BufferedImage imageToBuild;
    String block = "â–ˆ";
    int startIndex = 0;
    int placed = 0;
    int index = 0;
    SliderValue laziness = (SliderValue) this.config.create("Laziness", 0.8, 0.1, 2, 2).description("The laziness to place armor stands by"),
            range = (SliderValue) this.config.create("Range", 10, 5, 100, 0).description("The range to place armor stands in"),
            scaleWidthImage = (SliderValue) this.config.create("Image scale X", 70, 10, 200, 0).description("The image scale");
    BooleanValue spawnAsEgg = (BooleanValue) this.config.create("Is egg", false).description("Whether or not to spawn the hologram as a spawn egg"),
            isBaby = (BooleanValue) this.config.create("Is baby", false).description("Whether or not to spawn the hologram as baby");
    Vec3d ppos = null;

    public HologramAura() {
        super("HologramAura", "the funny", ModuleType.EXPLOIT);
        scaleWidthImage.showOnlyIf(() -> mode.getValue().equalsIgnoreCase("image"));
        range.showOnlyIf(() -> mode.getValue().equalsIgnoreCase("random") || mode.getValue().equalsIgnoreCase("sphere"));
        laziness.showOnlyIf(() -> mode.getValue().equalsIgnoreCase("sphere"));

        Events.Packets.registerEventHandler(PacketEvents.PACKET_SEND, event -> {
            if (!this.isEnabled()) return;
            if (event.getPacket() instanceof PlayerInteractBlockC2SPacket) {
                generate();
            }
        });
    }

    @Override
    public void tick() {
        Atomic.client.player.getInventory().selectedSlot = 0;
    }

    void generate() {
        HologramManager.Hologram generated = HologramManager.generate(text, Vec3d.ZERO).withChild(isBaby.getValue()).withEgg(spawnAsEgg.getValue());
        switch (mode.getValue().toLowerCase()) {
            case "random" -> {
                Random r = new Random();
                Vec3d cpos = ppos.add((r.nextDouble() - 0.5) * range.getValue(), (r.nextDouble() - 0.5) * range.getValue(), (r.nextDouble() - 0.5) * range.getValue());
                generated.withPosition(cpos);
            }
            case "sphere" -> {
                if (genSpherePoints.size() <= index) {
                    setEnabled(false);
                    Notification.create(6000, "Hologram aura", "Done building");
                }
                Vec3d spherePointCurrent = genSpherePoints.get(index).multiply(range.getValue());
                generated.withPosition(ppos.add(spherePointCurrent));
                index++;
            }
            case "image" -> {
                int max = imageToBuild.getHeight();
                if (index >= max) {
                    Notification.create(6000, "Hologram aura", "Done building");
                    setEnabled(false);
                    return;
                }
                StringBuilder builder = new StringBuilder();
                builder.append("[");
                for (int i = 0; i < imageToBuild.getWidth(); i++) {
                    int r = imageToBuild.getRGB(i, index);
                    int rP = r & 0xFFFFFF | 0xF000000;
                    builder.append("{\"text\":\"").append(block).append("\",\"color\":\"#")
                            .append(Integer.toString(rP, 16).substring(1)).append("\"},");
                }
                String mc = builder.substring(0, builder.length() - 1) + "]";
                index++;
                generated.withText(mc).withWrapName(false);
                generated.withPosition(ppos.add(0, -(index / 4.5f), 0));
            }
        }
        Atomic.client.player.getInventory().selectedSlot = 0;
        CreativeInventoryActionC2SPacket p = new CreativeInventoryActionC2SPacket(36, generated.generate());
        Atomic.client.getNetworkHandler().sendPacket(p);
    }

    @Override
    public void enable() {
        ppos = Atomic.client.player.getPos();
        if (text == null || argument == null) {
            Notification.create(6000, "Hologram aura error", "Please only enable hologramaura via the item exploits menu");
            setEnabled(false);
            return;
        }

        placed = 0;
        index = 0;
        startIndex = Atomic.client.player.getInventory().selectedSlot;

        genSpherePoints.clear();
        double incInv = Math.abs(laziness.getValue() - laziness.getMax());
        double res = 30 * incInv;
        for (double i = 0; i <= Math.PI; i += Math.PI / res) {
            double radius = Math.sin(i) * range.getValue();
            double y = Math.cos(i) * range.getValue();
            for (double a = 0; a < Math.PI * 2; a += Math.PI / res) {
                double x = Math.cos(a) * radius;
                double z = Math.sin(a) * radius;
                genSpherePoints.add(new Vec3d(x, y, z));
            }
        }

        if (mode.getValue().equalsIgnoreCase("image")) {
            try {
                URL u = new URL(argument);
                HttpURLConnection huc = (HttpURLConnection) u.openConnection();
                huc.setRequestProperty("User-Agent",
                        "Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:88.0) Gecko/20100101 Firefox/88.0");
                huc.connect();
                InputStream is = huc.getInputStream();
                BufferedImage loadedImage = ImageIO.read(is);
                double newWidth = scaleWidthImage.getValue();
                double scale = (double) loadedImage.getWidth() / newWidth;
                imageToBuild = resize(loadedImage, (int) (loadedImage.getWidth() / scale), (int) (loadedImage.getHeight() / scale));
                Notification.create(6000, "Hologram aura", "Loaded image successfully");
                huc.disconnect();
            } catch (Exception ignored) {
                Notification.create(6000, "Hologram aura", "Failed to load image");
                setEnabled(false);
            }
        }
    }

    private BufferedImage resize(BufferedImage img, int newW, int newH) {
        Image tmp = img.getScaledInstance(newW, newH, Image.SCALE_SMOOTH);
        BufferedImage dimg = new BufferedImage(newW, newH, BufferedImage.TYPE_INT_ARGB);

        Graphics2D g2d = dimg.createGraphics();
        g2d.drawImage(tmp, 0, 0, null);
        g2d.dispose();

        return dimg;
    }

    @Override
    public void disable() {
        imageToBuild = null;
        text = null;
        argument = null;
        CreativeInventoryActionC2SPacket p = new CreativeInventoryActionC2SPacket(36, new ItemStack(Items.AIR));
        Atomic.client.getNetworkHandler().sendPacket(p);
        Atomic.client.player.getInventory().selectedSlot = startIndex;
    }

    @Override
    public String getContext() {
        return placed + " S";
    }

    @Override
    public void onWorldRender(MatrixStack matrices) {

    }

    @Override
    public void onHudRender() {

    }
}

